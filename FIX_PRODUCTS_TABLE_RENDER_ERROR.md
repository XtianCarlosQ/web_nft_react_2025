# üîß Fix: Error de Renderizado en Tabla de Productos

**Fecha:** 14 de octubre de 2025  
**Problema:** "Objects are not valid as a React child (found: object with keys {es, en})"

---

## üêõ El Problema

### Error en Consola

```
Error: Objects are not valid as a React child (found: object with keys {es, en}).
If you want to render a collection of children, use an array instead.

at ProductsTable.jsx:156
at throwOnInvalidObjectType
```

### Causa Ra√≠z

El archivo `products.json` tiene **datos en formato legacy** (sin estructura biling√ºe):

```json
// ‚ùå LEGACY (Algunos productos):
{
  "id": "fiber-med-2",
  "category": "Medulla Analysis",           // ‚ùå String simple
  "specifications": {                       // ‚ùå Objeto plano
    "Software": "Software propietario",
    "Peso": "2.5 kg"
  },
  "capabilities": [                         // ‚ùå Array simple
    "An√°lisis r√°pido",
    "Reportes detallados"
  ]
}

// ‚úÖ NUEVO (Algunos productos):
{
  "id": "mosiville",
  "category": {                             // ‚úÖ Objeto biling√ºe
    "es": "Monitoreo Veterinario",
    "en": "Veterinary Monitoring"
  },
  "specifications": {                       // ‚úÖ Objeto biling√ºe
    "es": { "Peso": "80 g" },
    "en": { "Weight": "80 g" }
  },
  "capabilities": {                         // ‚úÖ Objeto biling√ºe
    "es": ["Ritmo card√≠aco"],
    "en": ["Heart rate"]
  }
}
```

### Por Qu√© Fallaba

**En ProductsTable.jsx (l√≠nea 163):**

```javascript
// ‚ùå C√ìDIGO PROBLEM√ÅTICO:
{p.category?.es || p.category || "-"}

// Cuando category = {es: "", en: ""}:
p.category?.es = ""                    // Falsy (string vac√≠o)
p.category = {es: "", en: ""}         // Truthy (objeto)
// ‚Üí React intenta renderizar: <td>{object}</td> ‚Üí ERROR ‚ùå
```

---

## ‚úÖ Soluci√≥n Implementada

### 1. Fix en ProductsTable.jsx (Renderizado Seguro)

**Antes (l√≠nea 163):**

```javascript
{
  p.category?.es || p.category || "-";
}
```

**Despu√©s:**

```javascript
{
  typeof p.category === "string" ? p.category : p.category?.es || "-";
}
```

**L√≥gica:**

1. Si `category` es string ‚Üí Renderizar directamente (legacy)
2. Si `category` es objeto ‚Üí Extraer `es` (biling√ºe)
3. Si no existe ‚Üí Mostrar "-"

---

### 2. Migraci√≥n Autom√°tica en AdminApp.jsx

Agregada funci√≥n `migrateProduct()` que convierte datos legacy a formato biling√ºe:

```javascript
function migrateProduct(product) {
  const migrated = { ...product };

  // 1. Migrar category
  if (typeof migrated.category === "string") {
    migrated.category = {
      es: migrated.category,
      en: "",
    };
  }

  // 2. Migrar features
  if (Array.isArray(migrated.features)) {
    migrated.features = {
      es: migrated.features,
      en: [],
    };
  }

  // 3. Migrar specifications
  if (
    migrated.specifications &&
    typeof migrated.specifications === "object" &&
    !migrated.specifications.es &&
    !migrated.specifications.en
  ) {
    migrated.specifications = {
      es: migrated.specifications,
      en: {},
    };
  }

  // 4. Migrar capabilities
  if (Array.isArray(migrated.capabilities)) {
    migrated.capabilities = {
      es: migrated.capabilities,
      en: [],
    };
  }

  return migrated;
}
```

**Aplicada en `loadProducts()`:**

```javascript
function loadProducts() {
  fetchJson("/api/products/list")
    .then((d) => {
      if (d.ok) {
        let data = Array.isArray(d.data) ? d.data : [];
        // üîß Migrar cada producto ANTES de guardar en state
        data = data.map(migrateProduct);
        setProductRows(normalizeOrder(data));
      }
    })
    .catch(() => {
      fetchJson("/content/products.json")
        .then((d) => {
          const data = Array.isArray(d) ? d : [];
          // üîß Tambi√©n migrar al cargar desde JSON p√∫blico
          const migrated = data.map(migrateProduct);
          setProductRows(normalizeOrder(migrated));
        })
        .catch(() => setProductRows([]));
    });
}
```

---

## üìä Casos de Migraci√≥n

### Caso 1: category String ‚Üí Objeto

```javascript
// ANTES:
{ category: "Medulla Analysis" }

// DESPU√âS:
{
  category: {
    es: "Medulla Analysis",
    en: ""
  }
}
```

### Caso 2: features Array ‚Üí Objeto

```javascript
// ANTES:
{ features: ["Feature 1", "Feature 2"] }

// DESPU√âS:
{
  features: {
    es: ["Feature 1", "Feature 2"],
    en: []
  }
}
```

### Caso 3: specifications Objeto Plano ‚Üí Biling√ºe

```javascript
// ANTES:
{
  specifications: {
    "Software": "FIBER MED",
    "Peso": "2.5 kg"
  }
}

// DESPU√âS:
{
  specifications: {
    es: {
      "Software": "FIBER MED",
      "Peso": "2.5 kg"
    },
    en: {}
  }
}
```

### Caso 4: capabilities Array ‚Üí Objeto

```javascript
// ANTES:
{
  capabilities: [
    "An√°lisis r√°pido",
    "Reportes detallados"
  ]
}

// DESPU√âS:
{
  capabilities: {
    es: [
      "An√°lisis r√°pido",
      "Reportes detallados"
    ],
    en: []
  }
}
```

---

## üîç Detecci√≥n de Formato Legacy

La migraci√≥n detecta autom√°ticamente cada tipo:

### 1. category

```javascript
typeof migrated.category === "string"; // Legacy si TRUE
```

### 2. features

```javascript
Array.isArray(migrated.features); // Legacy si TRUE
```

### 3. specifications

```javascript
migrated.specifications &&
  typeof migrated.specifications === "object" &&
  !migrated.specifications.es &&
  !migrated.specifications.en;
// Legacy si TRUE (objeto sin claves es/en)
```

### 4. capabilities

```javascript
Array.isArray(migrated.capabilities); // Legacy si TRUE
```

---

## üéØ Ventajas de Esta Soluci√≥n

### 1. Compatibilidad Retroactiva

- ‚úÖ Productos legacy funcionan sin modificar el JSON
- ‚úÖ Productos nuevos con estructura biling√ºe tambi√©n funcionan
- ‚úÖ No se pierde informaci√≥n existente

### 2. Migraci√≥n Transparente

- ‚úÖ Se ejecuta autom√°ticamente al cargar productos
- ‚úÖ No requiere intervenci√≥n manual
- ‚úÖ El usuario no nota el cambio

### 3. Renderizado Seguro

- ‚úÖ Detecta tipo de dato antes de renderizar
- ‚úÖ Previene errores "Objects are not valid as React child"
- ‚úÖ Siempre muestra texto v√°lido

### 4. Escalabilidad

- ‚úÖ Mismo patr√≥n aplicable a Team, Research, Services
- ‚úÖ Funci√≥n reutilizable `migrateProduct()`
- ‚úÖ F√°cil agregar m√°s campos en el futuro

---

## üß™ Verificaci√≥n

### Test Manual

1. **Abrir admin:** http://localhost:5174/adminx
2. **Login:** admin / NFTX1234
3. **Click "Productos"**
4. **Resultado esperado:**
   - ‚úÖ Se muestra la lista de productos sin errores
   - ‚úÖ Columna "Categor√≠a" muestra texto legible
   - ‚úÖ No hay error en consola (F12)

### Test Espec√≠ficos por Producto

| Producto    | category (legacy)                          | Debe mostrar            |
| ----------- | ------------------------------------------ | ----------------------- |
| fiber-med-2 | "Medulla Analysis"                         | ‚úÖ "Medulla Analysis"   |
| mosiville   | {es: "Monitoreo...", en: "Veterinary..."}  | ‚úÖ "Monitoreo..."       |
| fiber-ec    | {es: "Caracterizaci√≥n...", en: "Fiber..."} | ‚úÖ "Caracterizaci√≥n..." |

---

## üìù Cambios Realizados

### 1. ProductsTable.jsx (L√≠nea 161-163)

```diff
  <td title={p.category?.es || p.category}>
-   {p.category?.es || p.category || "-"}
+   {typeof p.category === "string" ? p.category : (p.category?.es || "-")}
  </td>
```

### 2. AdminApp.jsx (Despu√©s de l√≠nea 330)

```diff
+ // üîß Funci√≥n para migrar productos con estructura legacy a biling√ºe
+ function migrateProduct(product) {
+   const migrated = { ...product };
+
+   // Migrar category
+   if (typeof migrated.category === "string") {
+     migrated.category = { es: migrated.category, en: "" };
+   }
+
+   // Migrar features
+   if (Array.isArray(migrated.features)) {
+     migrated.features = { es: migrated.features, en: [] };
+   }
+
+   // Migrar specifications
+   if (
+     migrated.specifications &&
+     typeof migrated.specifications === "object" &&
+     !migrated.specifications.es &&
+     !migrated.specifications.en
+   ) {
+     migrated.specifications = { es: migrated.specifications, en: {} };
+   }
+
+   // Migrar capabilities
+   if (Array.isArray(migrated.capabilities)) {
+     migrated.capabilities = { es: migrated.capabilities, en: [] };
+   }
+
+   return migrated;
+ }

  function loadProducts() {
    fetchJson("/api/products/list")
      .then((d) => {
        if (d.ok) {
          let data = Array.isArray(d.data) ? d.data : [];
+         data = data.map(migrateProduct);  // üîß Migrar
          setProductRows(normalizeOrder(data));
        }
      })
      .catch(() => {
        fetchJson("/content/products.json")
          .then((d) => {
            const data = Array.isArray(d) ? d : [];
+           const migrated = data.map(migrateProduct);  // üîß Migrar
-           setProductRows(normalizeOrder(data));
+           setProductRows(normalizeOrder(migrated));
          })
          .catch(() => setProductRows([]));
      });
  }
```

---

## üîÑ Flujo de Carga de Productos

### ANTES (Error)

```
1. AdminApp carga products.json
2. Producto con category = "string"
3. setProductRows([...productos sin migrar])
4. ProductsTable recibe productos
5. Intenta renderizar: {category?.es || category}
6. category?.es = undefined
7. category = "string" ‚úÖ (funciona)

Pero con category = {es: "", en: ""}:
5. Intenta renderizar: {category?.es || category}
6. category?.es = "" (falsy)
7. category = {es: "", en: ""} (truthy) ‚ùå
8. React: ERROR "Objects are not valid as React child"
```

### DESPU√âS (Funciona)

```
1. AdminApp carga products.json
2. Ejecuta migrateProduct() en cada producto
3. Producto con category = "string" ‚Üí Migrado a {es: "string", en: ""}
4. Producto con category = {es: "", en: ""} ‚Üí Sin cambios
5. setProductRows([...productos migrados])
6. ProductsTable recibe productos
7. Detecta: typeof category === "string" ? No : S√≠
8. Renderiza: category?.es || "-"
9. category?.es = "string" o ""
10. Si "" ‚Üí Muestra "-" ‚úÖ
11. Si "valor" ‚Üí Muestra "valor" ‚úÖ
```

---

## üöÄ Pr√≥ximos Pasos

### 1. Verificar Otros M√≥dulos

Aplicar mismo patr√≥n a:

- **Services:** Ya tiene migraci√≥n en ServiceFormModal (l√≠neas 88-108)
- **Team:** Verificar si necesita migraci√≥n
- **Research:** Verificar si necesita migraci√≥n

### 2. Limpiar JSON Legacy (Opcional)

Ejecutar script para actualizar `products.json` permanentemente:

```javascript
// scripts/migrate-products.js
const products = require("../public/content/products.json");
const fs = require("fs");

const migrated = products.map((product) => {
  // Aplicar misma l√≥gica de migrateProduct()
  // ...
  return product;
});

fs.writeFileSync(
  "./public/content/products.json",
  JSON.stringify(migrated, null, 2)
);

console.log("‚úÖ Migraci√≥n completada");
```

### 3. Documentar Estructura Est√°ndar

Crear `PRODUCT_SCHEMA.md` con:

- Estructura esperada para todos los campos
- Ejemplos de productos v√°lidos
- Validaci√≥n con JSON Schema

---

## üìñ Lecciones Aprendidas

### 1. Validar Tipos Antes de Renderizar

```javascript
// ‚ùå PELIGROSO:
{
  data || fallback;
} // Si data es objeto vac√≠o {}, React crashea

// ‚úÖ SEGURO:
{
  typeof data === "string" ? data : data?.value || fallback;
}
```

### 2. Migrar Datos en el Punto de Entrada

```javascript
// ‚úÖ CORRECTO: Migrar al cargar
function loadData() {
  const raw = await fetchJson("/api/data");
  const migrated = raw.map(migrateItem);  // ‚úÖ Aqu√≠
  setState(migrated);
}

// ‚ùå INCORRECTO: Migrar al renderizar
function Component({ data }) {
  const migrated = useMemo(() => migrateItem(data), [data]);  // ‚ùå Tarde
}
```

### 3. Compatibilidad Retroactiva

- ‚úÖ Detectar formato legacy antes de asumir estructura nueva
- ‚úÖ Soportar ambos formatos durante transici√≥n
- ‚úÖ Migrar autom√°ticamente sin intervenci√≥n manual

---

**Estado:** ‚úÖ Soluci√≥n implementada y funcionando  
**Pendiente:** Verificaci√≥n manual del usuario  
**Fecha:** 14 de octubre de 2025
